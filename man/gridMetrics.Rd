% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setGeneric.r, R/ClassLidar.r
\docType{methods}
\name{gridMetrics}
\alias{gridMetrics}
\alias{gridMetrics,Lidar-method}
\title{Rasterize the space and compute metrics for each cells}
\usage{
gridMetrics(obj, res, func, start = c(0, 0), option = NULL)

\S4method{gridMetrics}{Lidar}(obj, res, func, start = c(0, 0),
  option = NULL)
}
\arguments{
\item{obj}{An object of class \code{Lidar}}

\item{res}{numeric. The size of the cells}

\item{func}{the function to be apply to each cells}

\item{start}{vector x and y coordinates for the reference raster. Default is (0,0).}

\item{option}{character. Could be \code{"split_flightline"}. In this case algorithm will compute the metrics for each flightline individually. It return several times the same cells in overlaps.}
}
\value{
It returns a \code{data.table} with containing the metrics for each cells. The table have the class "gridMetrics" enabling to easily plot it.
}
\description{
Computes a series of descriptive statistics for a LiDAR dataset for each cells
of a grid.
}
\details{
Computes a series of descriptive statistics defined by the user. Output is a
data.frame in which each line is a raster (single grid cell), each column is a metric.
gridMetrics is similar to cloudMetrics except it computes metrics within each cell
in the output grid. The grid cells coordinates are pre-determinted for a given resolution.
So the algorithm will always provides the same coordinates independently of the dataset.
When start = (0,0) and res = 20 gridMetrics will produce the following raster centers (10,10), (10,30), (30,10) etc..
When start = (-10, -10) and res = 20 gridMetrics will produce the following raster centers (0,0), (0,20), (20,0) etc..
In Quebec (Canada) reference is (-831600,  117980) in NAD83 coordinate system. The function to be apply to each cells
is a classical function (see examples) which return a labelled list of metrics. The following existing function
can help the user to compute some metrics:
\itemize{
\item{\link[lidR:entropy]{entropy}}
\item{\link[lidR:vci]{vci}}
\item{\link[lidR:canopyMatrix]{canopyMatrix}}
\item{\link[lidR:LAD]{LAD}}
\item{\link[lidR:canopyClosure]{canopyClosure}}
\item{\link[lidR:fractal.dimension]{fractal.dimension}}
\item{\link[lidR:LAD]{LAD}}
} Basically there no predifined metrics. The users must write is own function to create metrics.
gridMetrics will dispach the LiDAR data for each cell in the user's function. The user write his
function without thinking about grid cells. Just thinking about a cloud of points (see example).
}
\examples{
LASfile <- system.file("extdata", "Megaplot.las", package="lidR")
lidar = LoadLidar(LASfile)

# Canopy surface model with 4 m^2 cells
gridMetrics(lidar, 2, max(Z)) \%>\% plot

# Mean height with 400 m^2 cells
gridMetrics(lidar, 20, mean(Z)) \%>\% plot

# Define your own metric function
myMetrics = function(z, i, angle, pulseID)
{
  ret = list(
        npulse  = length(unique(pulseID)),
        hmean   = mean(z),
        hmax    = max(z),
        imean   = mean(i),
        angle   = mean(abs(angle))
        )

   return(ret)
 }

metrics = gridMetrics(lidar, 20, myMetrics(Z, Intensity, ScanAngle, pulseID))

plot(metrics, "hmean")
plot(metrics, "hmax")
plot(metrics, "imean")
#etc.
}

