<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="css/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="css/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="css/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body>
    <header>
      <div class="inner">
        <a href="/lidR"><h1>lidR</h1></a>
        <h2>R package for airborne LiDAR data manipulation and visualisation for forestry applications</h2>
        <a href="https://github.com/Jean-Romain/lidR" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">


    <h1>Advanced used of gridMetrics</h1>

    <p>gridMetrics returns a list of plots with the associated metrics. But some plots fall in water and the algorithm cannot guess that. Some plots are incomplete because they fall in the edge of the file or in the edge of a flightline, or in this edge of a void area (providers removed some data) or other good reason. The algorithm makes cells but it does not control what was in the cells. You can control the cells quality using two ways.</p>

<p>The user must be able to filter the bad cells. Several possibilities are avaible.</p>

<h2 id="using-a-basic-controller-area">Using a basic controller: area</h2>

<p>We can add control metrics in the metric function. For example, compute the real spatial extent area of the plot</p>

<div class="highlighter-rouge"><pre class="highlight"><code>myMetrics = function(x, y, z, i, angle, pulseID)
{
	xmax = max(x)
	ymax = max(y)
	xmin = min(x)
	ymin = min(y)

  ret = list(
      A		    = (xmax - xmin)*(ymax - ymin),
      density = length(unique(pulseID))/400,
      hmean   = mean(z),
      hmax    = max(z),
      imean   = mean(i),
      angle   = mean(abs(angle))
  )
}
  
metrics = gridMetrics(lidar, 10, myMetrics(X, Y, Z, Intensity, ScanAngle, pulseID))
</code></pre>
</div>

<p>You can see that some plots have an area which is not 100 m^2 (10 x 10). That means that these plots are probably on the edge of the file or on the edge of the lake. Verification:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>plot(metrics, "A")
</code></pre>
</div>

<p><img src="images/gridMetrics-A.jpg" alt="" /></p>

<p>So the metrics must be cleaned</p>

<div class="highlighter-rouge"><pre class="highlight"><code>metricsCleaned = dplyr::filter(metrics, A &gt; 100*0.90)
</code></pre>
</div>

<p>The real area cannot be exactly 100 m^2 because the returns are discrete. Here we choosed 90% of 100 m^2.</p>

<h2 id="advanced-controller-filter-from-shapefiles">Advanced controller: filter from shapefiles</h2>

<p>Area control is no enough. We can classified the data based on geographic data found in shapefiles.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>shapefile_dir &lt;- system.file("extdata", package = "lidR")
lake = rgdal::readOGR(shapefile_dir, "lac_ontario_UTM17")
</code></pre>
</div>

<p>We can check if the LiDAR points are in polygons given in the shapefile (here polygon are lakes) with the function <code class="highlighter-rouge">classifyFromShapefile</code>. This function is documented <a href="classifyFromShapefile.html">here</a>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>lidar = classifyFromShapefile(lidar, lake, field="lake")
</code></pre>
</div>

<p>There is a now a new column named <code class="highlighter-rouge">lake</code>. Each point is classified. <code class="highlighter-rouge">TRUE</code>: the point is in a lake, <code class="highlighter-rouge">FALSE</code>: the point is not in a lake. You can filter the points with <code class="highlighter-rouge">extract</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>forest = lidar %&gt;% leach(lake == FALSE)
forest %&gt;% plot
</code></pre>
</div>

<p>You can also compute the number of point point classifiy as lake in the <code class="highlighter-rouge">gridMetrics</code> function:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>myMetrics = function(x, y, z, i, angle, pulseID, lake)
{
	xmax = max(x)
	ymax = max(y)
	xmin = min(x)
	ymin = min(y)

  ret = list(
      A		    = (xmax - xmin)*(ymax - ymin),
      nlake   = sum(lake),
      density = length(unique(pulseID))/400,
      hmean   = mean(z),
      hmax    = max(z),
      imean   = mean(i),
      angle   = mean(abs(angle))
  )
}
  
metrics = gridMetrics(lidar, 10, myMetrics(X, Y, Z, Intensity, ScanAngle, pulseID, lake))

plot(metrics, "nlake")
</code></pre>
</div>

<p><img src="images/gridMetrics-nlake.jpg" alt="" /></p>

<p>And filter the resulting raster which havenâ€™t points into a lake and which ave a propre area.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>metricsCleaned = dplyr::filter(metrics, A &gt; 380, nlake == 0)
plot(metricsCleaned, "hmean")
</code></pre>
</div>

<p><img src="images/gridMetrics-hmeanclean.jpg" alt="" /></p>


</section>

        <aside id="sidebar">
          <a href="https://github.com/Jean-Romain/lidR/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/Jean-Romain/lidR/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/Jean-Romain/lidR"></a> is maintained by <a href="https://github.com/Jean-Romain">Jean-Romain</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>

